#!/bin/bash
# SPDX-License-Identifier: GPL-2.0
# (c) 2018 Luis Chamberlain <mcgrof@kernel.org>
#
# This script is a full rewrite by Luis from the fio tools/fio_generate_plots
# for the purpose of fio-tests. Things are made more dynamic and data analysis
# is provided.
#
# The old header of the file had this notice:
#
# This script is an almost total rewrite by Louwrentius
# of the original fio_generate_plots script provided as part of the FIO storage
# benchmark utiliy. I only retained how GNUplot is used to generate graphs, as
# that is something I know nothing about.
#
# The script uses the files generated by FIO to create nice graphs in the
# SVG format. This output format is supported by most modern browsers and
# allows resolution independent graphs to be generated.
#
# This script supports GNUPLOT 4.4 and higher.

XLABEL=""
DIR=""
DIRBASE=""
SCALE=""
DEFAULT_X_RESOLUTION=1280
DEFAULT_Y_RESOLUTION=768
OUTPUT_FOCUS="io"

SET_X_RESOLUTION=$DEFAULT_X_RESOLUTION
SET_Y_RESOLUTION=$DEFAULT_Y_RESOLUTION

DEFAULT_GRID_LINE_TYPE=3
DEFAULT_LINE_WIDTH=2

usage()
{
	echo "Usage: $0 [ options ]"
	echo "[ options ]:"
	echo "-d | --dir     Directory to get test from"
	echo "-h | --help    Print help"
	echo "-x             Set resolution for x for the graphs, default: $DEFAULT_X_RESOLUTION" 
	echo "-y             Set resolution for y for the graphs, default: $DEFAULT_Y_RESOLUTION" 
	echo "-i | --io      Run for the IO depth range focus (default)"
	echo "-t | --thread  Run for the thread range focus"
}

parse_args()
{
	while [[ $# -gt 0 ]]; do
	key="$1"

	case $key in
	-h|--help)
		usage
		exit
	;;
	-x)
		SET_X_RESOLUTION="$2"
		shift
		shift
	;;
	-t|--thread)
		OUTPUT_FOCUS="thread"                                           
		shift   
	;;
	-i|--io)
		OUTPUT_FOCUS="io"
		shift   
	;;
	-y)
		SET_Y_RESOLUTION="$2"
		shift
		shift
	;;
	-d|--dir)
		DIR="$2"
		DIRBASE=$(basename $DIR)
		shift
		shift
	;;
	*)
		echo "Unknown parameter: $key"
		usage
		exit
	;;
	esac
	done
}

get_xscale()
{
	key=$1

	if [ "$OUTPUT_FOCUS" == "io" ]; then
		echo -n ";set logscale x 2;"
	fi
}

get_xoffset()
{
	key=$1

	case $key in
	bwr)
		echo -n ";set xrange [1:*];"
	;;
	bww)
		echo -n ";set xrange [1:*];"
	;;
	iopsr)
		echo -n ";set xrange [1:*];"
	;;
	iopsw)
		echo -n ";set xrange [1:*];"
	;;
	clatr)
		echo -n ";set xrange [1:*];"
	;;
	clatw)
		echo -n ";set xrange [1:*];"
	;;
	*)
		echo -n ";set xrange [0:*];"
	;;
	esac
}

get_xunit()
{
	if [ "$OUTPUT_FOCUS" == "io" ]; then
		echo -n "IO depth"
	elif [ "$OUTPUT_FOCUS" == "thread" ]; then
		echo -n "threads"
	else
		echo -n "Unknown xunit"
	fi
}

get_xlabel()
{
	key=$1
	echo -n ";set xlabel "

	if [ "$OUTPUT_FOCUS" == "io" ]; then
		echo -n "\"IO depth\" "
	elif [ "$OUTPUT_FOCUS" == "thread" ]; then
		echo -n "\"Threads\" "
	else
		echo -n "\"Unknown xlabel\" "
	fi
	echo -n " font $DEFAULT_AXIS_LABEL_FONT ;"
	get_xscale $key
	get_xoffset $key
}

get_yunit()
{
	key=$1

	case $key in
	bwr)
		echo -n "MiB/s"
	;;
	bww)
		echo -n "MiB/s"
	;;
	iopsr)
		echo -n "k IOPS"
	;;
	iopsw)
		echo -n "k IOPS"
	;;
	clatr)
		echo -n "ms"
	;;
	clatw)
		echo -n "ms"
	;;
	*)
		echo -n "Unknown unit"
	;;
	esac
}

get_yscale()
{
	echo ";set yrange [0:*];"
}

get_ylabel()
{
	key=$1
	echo -n ";set ylabel "

	case $key in
	bwr)
		echo -n "\"Mean read bandwidth (MiB/s)\" "
	;;
	bww)
		echo -n "\"Mean read bandwidth (MiB/s)\" "
	;;
	iopsr)
		echo -n "\"Mean read IOPS (k)\" "
	;;
	iopsw)
		echo -n "\"Mean read IOPS (k)\" "
	;;
	clatr)
		echo -n "\"Mean read completion latency (ms)\" "
	;;
	clatw)
		echo -n "\"Mean write completion latency (ms)\" "
	;;
	*)
		echo -n "\"Unknown\" "
	;;
	esac
	echo -n " font $DEFAULT_AXIS_LABEL_FONT ;"
	get_yscale $key
}

get_measure_name()
{
	case $1 in
	bwr)
        	echo -n "Read bandwidth"
	;;
	bww)
        	echo -n "Write bandwidth"
	;;
	iopsr)
        	echo -n "Read IOPS"
	;;
	iopsw)
        	echo -n "Write IOPS"
	;;
	clatr)
        	echo -n "Read completion latency"
	;;
	clatw)
        	echo -n "Write completion latency"
	;;
	*)
		echo -n "Unknown"
	;;
	esac
}

get_measure_color()
{
	case $1 in
	bwr)
        	echo -n "1"
	;;
	iopsr)
        	echo -n "2"
	;;
	clatr)
        	echo -n "3"
	;;
	bww)
        	echo -n "4"
	;;
	iopsw)
        	echo -n "5"
	;;
	clatw)
        	echo -n "6"
	;;
	*)
		echo -n "7"
	;;
	esac
}

readlink_portable()
{
	case $(uname -s) in
	Darwin)
		python -c "import os; print(os.path.realpath('$1'))"
	;;
	Linux)
		readlink -f $1
	;;
	*)
		echo $1
	;;
	esac
}

get_test_name()
{
	TEST_TITLE=$(readlink_portable $DIR)
	TEST_TITLE=${TEST_TITLE##*fio-tests/tests/}
	TEST_TITLE=$(echo $TEST_TITLE | sed -e 's|\./||g')

        echo -n ";set title "
	echo -n "\"${TEST_TITLE}\n"
        echo -n "\{/*0.6 "$1"}\" font $DEFAULT_TITLE_FONT;"
}

measure_scale()
{
	THIS_MEASURE=$1

	case $THIS_MEASURE in
	bwr)
		echo -n "1024"
	;;
	iopsr)
		echo -n "1000"
	;;
	clatr)
		echo -n "1000"
	;;
	bww)
		echo -n "1024"
	;;
	iopsw)
		echo -n "1000"
	;;
	clatw)
		echo -n "1000"
	;;
	*)
	;;
	esac
}

measure_column()
{
	MEASURE=$1

	case $MEASURE in
	bwr)
		echo -n "2"
	;;
	iopsr)
		echo -n "3"
	;;
	clatr)
		echo -n "4"
	;;
	bww)
		echo -n "5"
	;;
	iopsw)
		echo -n "6"
	;;
	clatw)
		echo -n "7"
	;;
	*)
	;;
	esac
}

get_data_measure_prefix()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	echo -n "stats '$FILE' using $(measure_column $MEASURE) nooutput name 'Y_';"
	echo -n "stats '$FILE' using 1 every ::Y_index_min::Y_index_min nooutput;"
	echo -n "X_min = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Y_index_max::Y_index_max nooutput;"
	echo -n "X_max = STATS_max;"
}

get_data_analysis_bwr_best_bw()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	get_data_measure_prefix $FILE $MEASURE
	echo -n "Y_max = Y_max / $SCALE ;"
	echo -n "set label 2 sprintf(\"Best bandwidth: %d $Y_UNIT    using   %d $X_UNIT\", Y_max, X_max) center at first X_max,Y_max point pt 7 ps 8 lc 10 offset 0,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_bwr_best_clat()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	# We want to label both the max bw but also where we get the
	# bw where we also know we get the minimum latency and max IOPS.
	# This requires some gnuplot magic.
	echo -n "stats '$FILE' using $(measure_column clatr) nooutput name 'Yclatr_';"
	echo -n "stats '$FILE' using 1 every ::Yclatr_index_min::Yclatr_index_min nooutput;"
	echo -n "X_min_clatr = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Yclatr_index_max::Yclatr_index_max nooutput;"
	echo -n "X_max_clatr = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_min_clatr:X_min_clatr];"
	echo -n "stats '$FILE' using 1:$(measure_column bwr) nooutput name 'Y_';"
	echo -n "Y_min_orig = Y_min_y;"
	echo -n "Ybw_best_clatr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 3 sprintf(\"Best latency point: %d $Y_UNIT    using   %d $X_UNIT\", Ybw_best_clatr, X_min_clatr) center at first X_min_clatr,Ybw_best_clatr point pt 7 ps 8 lc 4 offset 14,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_bwr_best_iops()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	# We want to label both the min latency and also the latency
	# at which we know we got the best IOPS, but we know it should
	# probably match in practice the same as where we get the best
	# bandwidth.
	echo -n "stats '$FILE' using $(measure_column iopsr) nooutput name 'Yiopsr_';"
	echo -n "stats '$FILE' using 1 every ::Yiopsr_index_min::Yiopsr_index_min nooutput;"
	echo -n "X_min_iopsr = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Yiopsr_index_max::Yiopsr_index_max nooutput;"
	echo -n "X_max_iopsr = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_max_iopsr:X_max_iopsr];"
	echo -n "stats '$FILE' using 1:$(measure_column bwr) nooutput name 'Y_';"
	echo -n "Ybw_best_iopsr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 4 sprintf(\"Best IOPS point: %d $Y_UNIT    using   %d $X_UNIT\", Ybw_best_iopsr, X_max_iopsr) center at first X_max_iopsr,Ybw_best_iopsr point pt 7 ps 8 lc 6 offset -14,3.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_bwr()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_bwr_best_bw $FILE $MEASURE
	get_data_analysis_bwr_best_clat $FILE $MEASURE
	get_data_analysis_bwr_best_iops $FILE $MEASURE
}

get_data_analysis_bww_best_bw()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	get_data_measure_prefix $FILE $MEASURE
	echo -n "Y_max = Y_max / $SCALE ;"
	echo -n "set label 2 sprintf(\"Best bandwidth: %d $Y_UNIT    using   %d $X_UNIT\", Y_max, X_max) center at first X_max,Y_max point pt 7 ps 8 lc 10 offset 0,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_bww_best_clat()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	# We want to label both the max bw but also where we get the
	# bw where we also know we get the minimum latency and max IOPS.
	# This requires some gnuplot magic.
	echo -n "stats '$FILE' using $(measure_column clatw) nooutput name 'Yclatr_';"
	echo -n "stats '$FILE' using 1 every ::Yclatr_index_min::Yclatr_index_min nooutput;"
	echo -n "X_min_clatr = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Yclatr_index_max::Yclatr_index_max nooutput;"
	echo -n "X_max_clatr = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_min_clatr:X_min_clatr];"
	echo -n "stats '$FILE' using 1:$(measure_column bww) nooutput name 'Y_';"
	echo -n "Y_min_orig = Y_min_y;"
	echo -n "Ybw_best_clatr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 3 sprintf(\"Best latency point: %d $Y_UNIT    using   %d $X_UNIT\", Ybw_best_clatr, X_min_clatr) center at first X_min_clatr,Ybw_best_clatr point pt 7 ps 8 lc 4 offset 14,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_bww_best_iops()
{
	FILE=$1
	MEASURE=$2

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	# We want to label both the min latency and also the latency
	# at which we know we got the best IOPS, but we know it should
	# probably match in practice the same as where we get the best
	# bandwidth.
	echo -n "stats '$FILE' using $(measure_column iopsw) nooutput name 'Yiopsr_';"
	echo -n "stats '$FILE' using 1 every ::Yiopsr_index_min::Yiopsr_index_min nooutput;"
	echo -n "X_min_iopsr = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Yiopsr_index_max::Yiopsr_index_max nooutput;"
	echo -n "X_max_iopsr = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_max_iopsr:X_max_iopsr];"
	echo -n "stats '$FILE' using 1:$(measure_column bww) nooutput name 'Y_';"
	echo -n "Ybw_best_iopsr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 4 sprintf(\"Best IOPS point: %d $Y_UNIT    using   %d $X_UNIT\", Ybw_best_iopsr, X_max_iopsr) center at first X_max_iopsr,Ybw_best_iopsr point pt 7 ps 8 lc 6 offset -14,3.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_bww()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_bwr_best_bw $FILE $MEASURE
	get_data_analysis_bww_best_clat $FILE $MEASURE
	get_data_analysis_bww_best_iops $FILE $MEASURE
}

get_data_analysis_iopsr_best_iops()
{
	FILE=$1
	MEASURE=$2

	get_data_measure_prefix $FILE $MEASURE
	echo -n "Y_max = Y_max / $SCALE;"
	echo -n "set label 2 sprintf(\"Max: %d $Y_UNIT    using   %d $X_UNIT\", Y_max, X_max) center at first X_max,Y_max point pt 7 ps 8 lc 10 offset 0,2.5 font $DEFAULT_AXIS_FONT;"
}

data_measure_type()
{
	MEASURE=$1

	case $MEASURE in
	bwr)
		echo -n "%d"
	;;
	iopsr)
		echo -n "%d"
	;;
	clatr)
		echo -n "%0.4f"
	;;
	bww)
		echo -n "%d"
	;;
	iopsw)
		echo -n "%d"
	;;
	clatw)
		echo -n "%0.4f"
	;;
	*)
	;;
	esac
}

get_data_analysis_target_best_bw()
{
	FILE=$1
	MEASURE=$2
	YOFFSET=$3

	# We want to label both the min latency and also the latency
	# at which we know we got the best bandwidth
	echo -n "stats '$FILE' using $(measure_column bwr) nooutput name 'Ybw_';"
	echo -n "stats '$FILE' using 1 every ::Ybw_index_min::Ybw_index_min nooutput;"
	echo -n "X_min_bw = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Ybw_index_max::Ybw_index_max nooutput;"
	echo -n "X_max_bw = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_max_bw:X_max_bw];"
	echo -n "stats '$FILE' using 1:$(measure_column $MEASURE) nooutput name 'Y_';"
	echo -n "Y_min_orig = Y_min_y;"
	echo -n "Ytarget_best_bwr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 3 sprintf(\"Best bandwidth point: $(data_measure_type $MEASURE) $Y_UNIT    using   %d $X_UNIT\", Ytarget_best_bwr, X_max_bw) center at first X_max_bw,Ytarget_best_bwr point pt 7 ps 8 lc 4 offset -14,$YOFFSET font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_target_best_lat()
{
	FILE=$1
	MEASURE=$2
	YOFFSET=$3
	LABEL_ID=$4
	LABEL_COLOR=$5

	Y_UNIT=$(get_yunit $MEASURE)
	X_UNIT=$(get_xunit)

	# We want to label both the min latency and also the latency
	# at which we know we got the best bandwidth
	echo -n "stats '$FILE' using $(measure_column bwr) nooutput name 'Yclatr_';"
	echo -n "stats '$FILE' using 1 every ::Yclatr_index_min::Yclatr_index_min nooutput;"
	echo -n "X_min_clatr = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Ybw_index_max::Ybw_index_max nooutput;"
	echo -n "X_max_clatr = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_min_clatr:X_min_clatr];"
	echo -n "stats '$FILE' using 1:$(measure_column $MEASURE) nooutput name 'Y_';"
	echo -n "Y_min_orig = Y_min_y;"
	echo -n "Ytarget_best_bwr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label $LABEL_ID sprintf(\"Best latency point: $(data_measure_type $MEASURE) $Y_UNIT    using   %d $X_UNIT\", Ytarget_best_bwr, X_min_clatr) center at first X_min_clatr,Ytarget_best_bwr point pt 7 ps 8 lc $LABEL_COLOR offset 14,$YOFFSET font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_iopsr_best_bw()
{
	FILE=$1
	MEASURE=$2
	get_data_analysis_target_best_bw $FILE $MEASURE 3.5
}

get_data_analysis_iopsr()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_iopsr_best_iops $FILE $MEASURE
	get_data_analysis_iopsr_best_bw $FILE $MEASURE
	get_data_analysis_target_best_lat $FILE $MEASURE 2.5 4 3
}

get_data_analysis_iopsw_best_iops()
{
	FILE=$1
	MEASURE=$2

	get_data_measure_prefix $FILE $MEASURE
	echo -n "Y_max = Y_max / $SCALE;"
	echo -n "set label 2 sprintf(\"Max: %d $Y_UNIT    using   %d $X_UNIT\", Y_max, X_max) center at first X_max,Y_max point pt 7 ps 8 lc 10 offset 0,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_iopsw_best_bw()
{
	FILE=$1
	MEASURE=$2
	get_data_analysis_target_best_bw $FILE $MEASURE 3.5
}

get_data_analysis_iopsw()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_iopsw_best_iops $FILE $MEASURE
	get_data_analysis_iopsw_best_bw $FILE $MEASURE
	get_data_analysis_target_best_lat $FILE $MEASURE 2.5 4 3
}

get_data_analysis_clatr_best_lat()
{
	FILE=$1
	MEASURE=$2
	
	get_data_measure_prefix $FILE $MEASURE
	echo -n "Y_min = Y_min / $SCALE ;"
	echo -n "set label 2 sprintf(\"Min: %0.4f $Y_UNIT    using   %d $X_UNIT\", Y_min, X_min) center at first X_min,Y_min point pt 7 ps 8 lc 2 offset 14,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_clatr_best_bw()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_target_best_bw $FILE $MEASURE 2.5
}

get_data_analysis_clatr_best_iops()
{
	FILE=$1
	MEASURE=$2

	# We want to label both the min latency and also the latency
	# at which we know we got the best IOPS, but we know it should
	# probably match in practice the same as where we get the best
	# bandwidth.
	echo -n "stats '$FILE' using $(measure_column iopsr) nooutput name 'Yiopsr_';"
	echo -n "stats '$FILE' using 1 every ::Yiopsr_index_min::Yiopsr_index_min nooutput;"
	echo -n "X_min_iopsr = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Ybw_index_max::Ybw_index_max nooutput;"
	echo -n "X_max_iopsr = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_max_iopsr:X_max_iopsr];"
	echo -n "stats '$FILE' using 1:$(measure_column clatr) nooutput name 'Y_';"
	echo -n "Ylat_best_iopsr = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 4 sprintf(\"Best IOPS point: %0.4f $Y_UNIT    using   %d $X_UNIT\", Ylat_best_iopsr, X_max_iopsr) center at first X_max_iopsr,Ylat_best_iopsr point pt 7 ps 8 lc 6 offset -14,3.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_clatr()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_clatr_best_lat $FILE $MEASURE
	get_data_analysis_clatr_best_bw $FILE $MEASURE
	get_data_analysis_clatr_best_iops $FILE $MEASURE
}

get_data_analysis_clatw_best_lat()
{
	FILE=$1
	MEASURE=$2
	
	get_data_measure_prefix $FILE $MEASURE
	echo -n "Y_min = Y_min / $SCALE ;"
	echo -n "set label 2 sprintf(\"Min: %0.4f $Y_UNIT    using   %d $X_UNIT\", Y_min, X_min) center at first X_min,Y_min point pt 7 ps 8 lc 2 offset 14,2.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_clatw_best_bw()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_target_best_bw $FILE $MEASURE 2.5
}

# XXX: unify these:
# get_data_analysis_clatw_best_iops
# get_data_analysis_clatr_best_iops
# The only difference are measure_column() calls for
# iopsw instead of iopsr, and clatw / clatr. This could be an easy fix.
get_data_analysis_clatw_best_iops()
{
	FILE=$1
	MEASURE=$2

	# We want to label both the min latency and also the latency
	# at which we know we got the best IOPS, but we know it should
	# probably match in practice the same as where we get the best
	# bandwidth.
	echo -n "stats '$FILE' using $(measure_column iopsw) nooutput name 'Yiopsw_';"
	echo -n "stats '$FILE' using 1 every ::Yiopsw_index_min::Yiopsw_index_min nooutput;"
	echo -n "X_min_iopsw = STATS_min ;"
	echo -n "stats '$FILE' using 1 every ::Ybw_index_max::Ybw_index_max nooutput;"
	echo -n "X_max_iopsw = STATS_max;"

	# gnuplot doesn't let you directly fetch the y value from an
	# x value, but we can cheat by limiting the range of a stat
	# computation.
	echo -n "set xrange [X_max_iopsw:X_max_iopsw];"
	echo -n "stats '$FILE' using 1:$(measure_column clatw) nooutput name 'Y_';"
	echo -n "Ylat_best_iopsw = Y_min_y / $SCALE ;"
	# Set the xrange back to what is should be
	echo -n "set xrange [1:*];"
	echo -n "set label 4 sprintf(\"Best IOPS point: %0.4f $Y_UNIT    using   %d $X_UNIT\", Ylat_best_iopsw, X_max_iopsw) center at first X_max_iopsw,Ylat_best_iopsw point pt 7 ps 8 lc 6 offset -14,3.5 font $DEFAULT_AXIS_FONT;"
}

get_data_analysis_clatw()
{
	FILE=$1
	MEASURE=$2

	get_data_analysis_clatw_best_lat $FILE $MEASURE
	get_data_analysis_clatw_best_bw $FILE $MEASURE
	get_data_analysis_clatw_best_iops $FILE $MEASURE
}

# See: http://soc.if.usp.br/manual/gnuplot-doc/htmldocs/stats_005f_0028Statistical_005fSummary_0029.html
get_data_analysis()
{
	FILE=$1
	MEASURE=$2

	case $MEASURE in
	bwr)
		get_data_analysis_bwr $FILE $MEASURE
	;;
	bww)
		get_data_analysis_bww $FILE $MEASURE
	;;
	iopsr)
		get_data_analysis_iopsr $FILE $MEASURE
	;;
	iopsw)
		get_data_analysis_iopsw $FILE $MEASURE
	;;
	clatr)
		get_data_analysis_clatr $FILE $MEASURE
	;;
	clatw)
		get_data_analysis_clatw $FILE $MEASURE
	;;
	*)
	;;
	esac
}

measure_range()
{
	MEASURE=$1
	SCALE=$2

	case $MEASURE in
	bwr)
		echo -n "(\$1):(\$$(measure_column $MEASURE)/${SCALE})"
	;;
	bww)
		echo -n "(\$1):(\$$(measure_column $MEASURE)/${SCALE})"
	;;
	iopsr)
		echo -n "(\$1):(\$$(measure_column $MEASURE)/${SCALE})"
	;;
	iopsw)
		echo -n "(\$1):(\$$(measure_column $MEASURE)/${SCALE})"
	;;
	clatr)
		echo -n "(\$1):(\$$(measure_column $MEASURE)/${SCALE})"
	;;
	clatw)
		echo -n "(\$1):(\$$(measure_column $MEASURE)/${SCALE})"
	;;
	*)
	;;
	esac
}

average_column()
{
	COLUMN="$1"
	FILE=$2

	awk '{sum += $'$COLUMN'} END {print sum/NR}' $FILE
}

verify_measure()
{
	MEASURE="$1"
	FILE=$2

	COLUMN=$(measure_column $MEASURE)
	AVERAGE=$(average_column $COLUMN $FILE)

	if [ "$AVERAGE" == "0" ]; then
		return -1
	fi

	return 0
}

plot()
{
	PLOT_TITLE=$(get_test_name)
	MEASURE="$1"
	FILE=$2
	MEASURE_NAME=$(get_measure_name $MEASURE)
	SCALE=$(measure_scale $MEASURE)
	RANGE=$(measure_range $MEASURE $SCALE)

	verify_measure $MEASURE $FILE
	if [ $? -ne 0 ]; then
		# Data values for this measure is 0, so skip graphing it
		exit 0
	fi

	ANALYZE_DATA=$(get_data_analysis $FILE $MEASURE)
	PLOT_LINE="'$FILE' using $RANGE title \"$MEASURE_NAME\" with linespoints ls $(get_measure_color $MEASURE)"

	OUTPUT="set output \"$DIRBASE-$MEASURE.svg\" "

	# We skip the warnings of "Can't compute errors of slope and intercep"
	# as these are generated due to our data analysis hack of computing
	# stats over the xrange[foo:foo] just so we can get the y value
	# for that respecgive x position, as there is no other easy way to
	# do this with gnuplot.
	echo " $PLOT_TITLE ; $(get_ylabel $MEASURE) ; $DEFAULT_OPTS ; $ANALYZE_DATA ; $(get_xlabel $MEASURE) ; $OUTPUT ; plot "  $PLOT_LINE  | $GNUPLOT - 2>&1 | grep -v "Can't compute errors of slope and intercep"
	unset PLOT_LINE
}

GNUPLOT=$(which gnuplot)
if [ ! -x "$GNUPLOT" ]; then
	echo "gnuplot not installed"
	exit 1
fi

parse_args $@

DEFAULT_LINE_COLORS="set object 1 rectangle from screen 0,0 to screen 1,1 fillcolor rgb\"#ffffff\" behind;
set style line 1 lc rgb \"#7CAB6A\" lw $DEFAULT_LINE_WIDTH lt 2 pt 7 pi -1 ps 1;
set style line 2 lc rgb \"#5A983E\" lw $DEFAULT_LINE_WIDTH lt 2 pt 7 pi -1 ps 1;
set style line 3 lc rgb \"#3E661C\" lw $DEFAULT_LINE_WIDTH lt 2 pt 7 pi -1 ps 1;

set style line 4 lc rgb \"#9d0a0a\" lw $DEFAULT_LINE_WIDTH lt 2 pt 7 pi -1 ps 1;
set style line 5 lc rgb \"#6b0a0a\" lw $DEFAULT_LINE_WIDTH lt 2 pt 7 pi -1 ps 1;
set style line 6 lc rgb \"#8c0a0a\" lw $DEFAULT_LINE_WIDTH lt 2 pt 7 pi -1 ps 1;

set style line 20 lc rgb \"#000000\" lt $DEFAULT_GRID_LINE_TYPE lw $DEFAULT_LINE_WIDTH;
set style fill solid 1.0;
set pointintervalbox 2;
"

DEFAULT_TERMINAL="set terminal svg enhanced dashed size $SET_X_RESOLUTION,$SET_Y_RESOLUTION dynamic"
DEFAULT_TITLE_FONT="\"Helvetica,28\""
DEFAULT_AXIS_FONT="\"Helvetica,14\""
DEFAULT_AXIS_LABEL_FONT="\"Helvetica,16\""
DEFAULT_XTIC="set xtics font $DEFAULT_AXIS_FONT"
DEFAULT_YTIC="set ytics font $DEFAULT_AXIS_FONT"

DEFAULT_MXTIC="set mxtics 2"
DEFAULT_MYTIC="set mytics 2"

DEFAULT_GRID="set grid ls 20"
DEFAULT_KEY="set key outside bottom center ; set key box enhanced spacing 2.0 samplen 20 horizontal width 4 height 1.2 nobox"
DEFAULT_SOURCE="set label 30 \"Host: $(hostname)\" font $DEFAULT_AXIS_FONT tc rgb \"#00000f\" at screen 0.976,0.115 right"
DEFAULT_OPTS="$DEFAULT_LINE_COLORS ; $DEFAULT_GRID_LINE ; $DEFAULT_GRID ; $DEFAULT_GRID_MINOR ; $DEFAULT_XTIC ;  $DEFAULT_YTIC ; $DEFAULT_MXTIC ; $DEFAULT_MYTIC ; $DEFAULT_KEY ; $DEFAULT_TERMINAL ; $DEFAULT_SOURCE"


if [ "$DIR" = "" ]; then
	DIR=$(pwd)
	DIRBASE=$(basename $DIR)
fi

INPUT_SSV="${DIR}/${DIRBASE}.ssv"

if [ ! -f $INPUT_SSV ]; then
	echo "File not found: $INPUT_SSV"
	exit
fi

plot bwr $INPUT_SSV
plot iopsr $INPUT_SSV
plot clatr $INPUT_SSV

plot bww $INPUT_SSV
plot clatw $INPUT_SSV
plot iopsw $INPUT_SSV
